package summarize

import (
	"math"
	"reflect"
	"testing"
)

func compAtom(a, b Atom, eps float64) bool {
	if a.Sym != b.Sym {
		return false
	}
	if math.Abs(a.X-b.X) > eps {
		return false
	}
	if math.Abs(a.Y-b.Y) > eps {
		return false
	}
	if math.Abs(a.Z-b.Z) > eps {
		return false
	}
	return true
}

func TestIntder(t *testing.T) {
	tests := []struct {
		infile string
		want   Intder
	}{
		{
			infile: "testfiles/intder.out",
			want: Intder{
				Geom: []Atom{
					{"C", 0.0000000000, 0.0000000000, -0.8888094004},
					{"C", 0.0000000000, 0.6626968171, 0.3682892206},
					{"C", 0.0000000000, -0.6626968171, 0.3682892206},
					{"H", 0.0000000000, 1.5951938489, 0.9069605214},
					{"H", 0.0000000000, -1.5951938489, 0.9069605214},
				},
				SiIC: [][]int{
					{1, 2, -1, -1, 0},
					{0, 1, -1, -1, 0},
					{0, 2, -1, -1, 0},
					{1, 3, -1, -1, 0},
					{2, 4, -1, -1, 0},
					{3, 1, 0, -1, 1},
					{4, 2, 0, -1, 1},
					{3, 1, 0, 2, 2},
					{4, 2, 0, 1, 2},
				},
				SyIC: [][]int{
					{0},
					{1, 2},
					{3, 4},
					{5, 6},
					{1, -2},
					{3, -4},
					{5, -6},
					{7, -8},
					{7, 8},
				},
				Freq: []float64{
					785.1, 901.7, 908.6,
					992.8, 1090.6, 1307.4,
					1623.6, 3247.6, 3281.4,
				},
				Vibs: `1.000S_{8}
0.809S_{4}+0.133S_{2}-0.057S_{1}
0.810S_{7}+0.189S_{5}
1.000S_{9}
0.809S_{5}-0.190S_{7}
0.686S_{2}-0.187S_{4}-0.126S_{1}
0.793S_{1}+0.174S_{2}
0.998S_{6}
0.971S_{3}
`,
			},
		},
		{
			infile: "testfiles/mason.out",
			want: Intder{
				Geom: []Atom{
					{"He", 0.0000000000, 0.0000000000, -1.7679827066},
					{"H", 0.0000000000, 0.0000000000, -0.5307856662},
					{"H", 0.0000000000, 0.0000000000, 0.5307856678},
					{"He", 0.0000000000, 0.0000000000, 1.7679827049},
				},
				Dumm: []Atom{
					{"X", 0.5879746785, 0.0000000000, -0.5307856277},
					{"X", 0.0000000000, 0.5879746785, -0.5307856277},
					{"X", 0.5879746785, 0.0000000000, 0.5307856294},
					{"X", 0.0000000000, 0.5879746785, 0.5307856294},
				},
				SiIC: [][]int{
					{0, 1, -1, -1, STRE},
					{1, 2, -1, -1, STRE},
					{2, 3, -1, -1, STRE},
					{0, 1, 2, 4, LIN1},
					{3, 2, 1, 6, LIN1},
					{0, 1, 2, 5, LIN1},
					{3, 2, 1, 7, LIN1},
				},
				SyIC: [][]int{
					{0},
					{1},
					{2},
					{3},
					{4},
					{5},
					{6},
				},
				Freq: []float64{
					228.4, 228.4, 280.1,
					398.6, 705.7, 705.7,
					2313.8,
				},
				Vibs: `0.500S_{4}-0.500S_{5}
0.500S_{6}-0.500S_{7}
0.500S_{3}-0.500S_{1}
0.455S_{1}+0.455S_{3}+0.090S_{2}
0.500S_{7}+0.500S_{6}
0.500S_{5}+0.500S_{4}
0.910S_{2}-0.045S_{1}-0.045S_{3}
`,
			},
		},
		{
			infile: "testfiles/prob.intder.out",
			want: Intder{
				Geom: []Atom{
					{"Ne", 0.0000000000, 0.0000000000, -0.7343384575},
					{"H", 0.0000000000, 0.0000000000, 0.5385631038},
					{"H", 0.0000000000, 0.0000000000, 1.6123863803},
					{"He", 0.0000000000, 0.0000000000, 3.1526459500},
				},
				Dumm: []Atom{
					{"X", 0.5879746785, 0.0000000000, 0.5385630647686742},
					{"X", 0.0000000000, 0.5879746785, 0.5385630647686742},
					{"X", 0.5879746785, 0.0000000000, 1.6123862634654555},
					{"X", 0.0000000000, 0.5879746785, 1.6123862634654555},
				},
				SiIC: [][]int{
					{0, 1, -1, -1, STRE},
					{1, 2, -1, -1, STRE},
					{2, 3, -1, -1, STRE},
					{0, 1, 2, 4, LIN1},
					{3, 2, 1, 6, LIN1},
					{0, 1, 2, 5, LIN1},
					{3, 2, 1, 7, LIN1},
				},
				SyIC: [][]int{
					{0},
					{1},
					{2},
					{3},
					{4},
					{5},
					{6},
				},
				Freq: []float64{
					144.3, 144.3, 149.1,
					649.6, 649.6, 743.4,
					2170.4,
				},
				Vibs: `0.831S_{5}-0.169S_{4}
0.831S_{7}-0.169S_{6}
1.053S_{3}-0.123S_{1}+0.070S_{2}
0.831S_{6}+0.169S_{7}
0.831S_{4}+0.169S_{5}
1.052S_{1}-0.094S_{3}+0.042S_{2}
0.887S_{2}-0.072S_{1}-0.041S_{3}
`,
			},
		},
		{
			infile: "testfiles/linx.out",
			want: Intder{
				Geom: []Atom{
					{"O", 0.0000000000, 0.0613294244, 2.2297334355},
					{"Al", 0.0000000000, 0.0240349320, 0.6300416085},
					{"N", 0.0000000000, -0.5099934476, -1.3063202649},
					{"O", 0.0000000000, 0.3463206604, -2.1474911562},
				},
				SiIC: [][]int{
					{0, 1, -1, -1, STRE},
					{1, 2, -1, -1, STRE},
					{2, 3, -1, -1, STRE},
					{1, 2, 3, -1, BEND},
					{3, 2, 1, 0, LINX},
					{3, 2, 1, 0, LINY},
				},
				SyIC: [][]int{
					{0},
					{1},
					{2},
					{3},
					{4},
					{5},
				},
				Freq: []float64{
					57.6,
					91.1,
					259.1,
					410.9,
					1078.8,
					1506.9,
				},
				Vibs: `0.766S_{5}-0.222S_{4}
1.000S_{6}
0.759S_{2}+0.149S_{4}+0.110S_{5}
0.640S_{4}-0.231S_{2}+0.120S_{5}
0.977S_{1}
1.030S_{3}
`,
			},
		},
		{
			infile: "testfiles/chris.out",
			want: Intder{
				Geom: []Atom{
					{"Si", 0.0000000000, 0.0000000000, 1.6772179406},
					{"C", 0.0000000000, 0.7270966774, 0.0000000000},
					{"C", 0.0000000000, -0.7270966774, 0.0000000000},
					{"Si", 0.0000000000, 0.0000000000, -1.6772179406},
				},
				SiIC: [][]int{
					{0, 1, -1, -1, STRE},
					{0, 2, -1, -1, STRE},
					{1, 3, -1, -1, STRE},
					{2, 3, -1, -1, STRE},
					{0, 3, -1, -1, STRE},
					{1, 2, -1, -1, STRE},
					{3, 2, 1, 0, TORS},
				},
				SyIC: [][]int{
					{4, 5},
					{4, -5},
					{0, -1, -2, 3},
					{6},
					{0, 1, -2, -3},
					{0, -1, 2, -3},
				},
				Freq: []float64{
					199.4,
					386.0,
					522.8,
					981.0,
					1003.1,
					1078.7,
				},
				Vibs: `1.000S_{4}
1.000S_{6}
0.719S_{2}+0.281S_{1}
1.000S_{3}
1.000S_{5}
0.719S_{1}-0.281S_{2}
`,
			},
		},
	}
	for _, test := range tests {
		got := ReadIntder(test.infile)
		if !reflect.DeepEqual(got, test.want) {
			if !reflect.DeepEqual(got.Geom, test.want.Geom) ||
				!reflect.DeepEqual(got.Dumm, test.want.Dumm) {
				got := append(got.Geom, got.Dumm...)
				want := append(test.want.Geom, test.want.Dumm...)
				for i := range got {
					if !compAtom(got[i], want[i], 1e-10) {
						t.Errorf("got\n%v, wanted\n%v\n",
							got[i], want[i])
					}
				}
			}
			if !reflect.DeepEqual(got.SiIC, test.want.SiIC) {
				t.Errorf("got\n%v, test.wanted\n%v\n", got.SiIC, test.want.SiIC)
			}
			if !reflect.DeepEqual(got.SyIC, test.want.SyIC) {
				t.Errorf("got\n%v, test.wanted\n%v\n", got.SyIC, test.want.SyIC)
			}
			if !reflect.DeepEqual(got.Freq, test.want.Freq) {
				t.Errorf("got\n%v, test.wanted\n%v\n", got.Freq, test.want.Freq)
			}
			if !reflect.DeepEqual(got.Vibs, test.want.Vibs) {
				t.Errorf("got\n%v, test.wanted\n%v\n", got.Vibs,
					test.want.Vibs)
			}
		}
	}
}
